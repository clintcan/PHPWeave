# Sample environment configuration for Docker/Kubernetes deployments
# This file supports both traditional .env mounting and modern environment variable approaches
#
# DEPLOYMENT METHOD 1: Traditional docker-compose with .env file mounting
#   - Copy to .env: cp .env.docker.sample .env
#   - Edit values: nano .env
#   - Run: docker compose up -d
#   - Uses DBHOST, DBNAME, DBUSER, DBPASSWORD naming
#
# DEPLOYMENT METHOD 2: Kubernetes-style environment variables
#   - Copy to .env.docker: cp .env.docker.sample .env.docker
#   - Edit values: nano .env.docker
#   - Source before running: source .env.docker
#   - Run: docker compose -f docker-compose.env.yml up -d
#   - Uses DB_HOST, DB_NAME, DB_USER, DB_PASSWORD naming

# ============================================================================
# DATABASE CONFIGURATION
# ============================================================================

# Modern naming (for Kubernetes/environment variable deployments)
DB_HOST=db
DB_NAME=phpweave
DB_USER=phpweave_user
DB_PASSWORD=change_this_password
DB_CHARSET=utf8mb4
DB_PORT=3306
DB_DRIVER=pdo_mysql

# Traditional naming (for .env file mounting - backward compatibility)
# PHPWeave automatically detects and uses either naming convention
DBHOST=db
DBNAME=phpweave
DBUSER=phpweave_user
DBPASSWORD=change_this_password
DBCHARSET=utf8mb4
# For MySQL/MariaDB port is 3306, for PostgreSQL is 5432, for SQLite is 0, for SQL Server is 1433
# For Firebird is 3050, for Oracle is 1521, for ODBC is 0
DBPORT=3306
# Supported drivers: pdo_mysql, pdo_pgsql, pdo_sqlite, pdo_sqlsrv, pdo_firebird, pdo_dblib, pdo_odbc
DBDRIVER=pdo_mysql

# MySQL Root Password (for docker-compose MySQL service initialization)
MYSQL_ROOT_PASSWORD=change_root_password

# ============================================================================
# APPLICATION SETTINGS
# ============================================================================

# Debug mode: 0=production (no errors displayed), 1=development (show errors)
DEBUG=0

# Environment indicators (for Docker detection and configuration)
DOCKER_ENV=production
PHPWEAVE_ENV=production

# ============================================================================
# PORT CONFIGURATION (optional overrides)
# ============================================================================

APP_PORT=8080        # Port for docker-compose.yml (single container)
DEV_PORT=8080        # Port for docker-compose.dev.yml (development mode)
NGINX_PORT=80        # Port for docker-compose.scale.yml (load-balanced)

# ============================================================================
# DEVELOPMENT TOOLS
# ============================================================================

# Xdebug Configuration (for docker-compose.dev.yml)
XDEBUG_MODE=debug

# ============================================================================
# USAGE EXAMPLES
# ============================================================================
#
# METHOD 1: Traditional .env file mounting (docker-compose.yml)
# ---------------------------------------------------------------
# 1. Copy this file to .env:
#    cp .env.docker.sample .env
#
# 2. Edit with your values (uses DBHOST, DBNAME, etc.):
#    nano .env
#
# 3. Run docker-compose:
#    docker compose up -d
#
# 4. The .env file is mounted into the container at runtime
#
#
# METHOD 2: Environment variables (docker-compose.env.yml)
# ---------------------------------------------------------------
# 1. Copy this file to .env.docker:
#    cp .env.docker.sample .env.docker
#
# 2. Edit with your values (uses DB_HOST, DB_NAME, etc.):
#    nano .env.docker
#
# 3. Source the file to export variables:
#    source .env.docker
#
# 4. Run docker-compose with environment variable file:
#    docker compose -f docker-compose.env.yml up -d
#
# 5. Variables are injected as environment variables at runtime
#
#
# METHOD 3: Development mode with volume mounting
# ---------------------------------------------------------------
# 1. Source environment variables:
#    source .env.docker
#
# 2. Run development compose file:
#    docker compose -f docker-compose.dev.yml up -d
#
# 3. Code changes are reflected immediately (volume mounted)
# 4. Xdebug enabled for debugging
#
#
# METHOD 4: Scaled deployment with load balancing
# ---------------------------------------------------------------
# 1. Source environment variables:
#    source .env.docker
#
# 2. Run scaled deployment:
#    docker compose -f docker-compose.scale.yml up -d
#
# 3. Creates 3 app containers behind Nginx load balancer
# 4. Access via http://localhost:80
#
#
# METHOD 5: Manual environment variable export
# ---------------------------------------------------------------
# 1. Export specific variables (alternative to sourcing):
#    export DB_HOST=db
#    export DB_NAME=phpweave
#    export DB_PASSWORD=my_secure_password
#    export DB_USER=custom_user
#
# 2. Run any docker-compose file:
#    docker compose -f docker-compose.env.yml up -d
#
#
# KUBERNETES DEPLOYMENT
# ---------------------------------------------------------------
# 1. Create ConfigMap from this file:
#    kubectl create configmap phpweave-config --from-env-file=.env.docker
#
# 2. Create Secret for sensitive data:
#    kubectl create secret generic phpweave-secrets \
#      --from-literal=DB_PASSWORD=your_password \
#      --from-literal=MYSQL_ROOT_PASSWORD=your_root_password
#
# 3. Reference in your deployment YAML:
#    envFrom:
#      - configMapRef:
#          name: phpweave-config
#      - secretRef:
#          name: phpweave-secrets
#
# ============================================================================
# NOTES
# ============================================================================
#
# - PHPWeave framework automatically detects which naming convention to use
# - Both DB_* and DB* naming conventions are supported simultaneously
# - The ${VAR:-default} syntax in docker-compose files means:
#   * Use host's $VAR environment variable if set
#   * Otherwise use the default value specified after :-
# - For security, never commit .env or .env.docker files to version control
# - Change all passwords before deploying to production
# - Use DEBUG=0 in production to prevent information disclosure
